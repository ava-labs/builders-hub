---
title: Deploy a Layer 1
description: Create and deploy your own Avalanche L1 blockchain with custom features
---

# Deploy a Layer 1 (Avalanche L1)

Create your own application-specific blockchain (Appchain) on Avalanche. Build a custom Layer 1 with your own rules, tokenomics, and governance.

## What You'll Build

By the end of this guide, you'll have:
- A custom Avalanche L1 running your application
- Understanding of L1 architecture and configuration
- Your own blockchain with custom features and economics

## Prerequisites

- Basic understanding of blockchain concepts
- Familiarity with command line interfaces
- Understanding of virtualization and networking
- Access to cloud infrastructure (recommended)

## Why Build an Appchain?

### Benefits of Avalanche L1s

- **Full Control**: Custom consensus, tokenomics, and governance
- **Performance**: Dedicated resources without network congestion
- **Cost Efficiency**: Predictable and often lower transaction costs
- **Interoperability**: Native communication with other Avalanche chains
- **Compliance**: Ability to implement specific regulatory requirements

### Use Cases

- **Gaming**: High-throughput gaming platforms
- **DeFi**: Specialized financial applications
- **Enterprise**: Private or consortium blockchains
- **NFT Marketplaces**: Custom NFT ecosystems
- **IoT**: Internet of Things applications

## Step 1: Plan Your L1

### Architecture Decisions

Choose your L1 configuration:

**Virtual Machine (VM)**:
- **Subnet-EVM**: Ethereum-compatible (most popular)
- **Custom VM**: Built with Avalanche SDK
- **Existing VMs**: SpacesVM, TimestampVM, etc.

**Consensus Mechanism**:
- **Snowman++**: High-performance consensus
- **Custom Consensus**: For specific requirements

**Validator Set**:
- **Permissioned**: Controlled validator set
- **Permissionless**: Open validation
- **Hybrid**: Mixed approach

## Step 2: Set Up Development Environment

### Install Avalanche CLI

```bash
# Install Avalanche CLI
curl -sSfL https://raw.githubusercontent.com/ava-labs/avalanche-cli/main/scripts/install.sh | sh -s

# Add to PATH (add to ~/.bashrc or ~/.zshrc)
export PATH=$PATH:$HOME/.avalanche-cli/bin

# Verify installation
avalanche --version
```

### Install Dependencies

```bash
# Install Go (required for custom VMs)
# On macOS
brew install go

# On Ubuntu/Debian
sudo apt update
sudo apt install golang-go

# Verify Go installation
go version
```

## Step 3: Create Your L1

### Using Avalanche CLI (Recommended)

```bash
# Create a new L1
avalanche blockchain create myAppchain

# Follow the interactive prompts:
# - Choose Subnet-EVM for Ethereum compatibility
# - Configure chain ID (use unique ID)
# - Set gas limit and target block rate
# - Configure initial token allocation
```

### Configuration Options

**Chain Configuration**:
```json
{
  "chainId": 12345,
  "homesteadBlock": 0,
  "eip150Block": 0,
  "eip155Block": 0,
  "eip158Block": 0,
  "byzantiumBlock": 0,
  "constantinopleBlock": 0,
  "petersburgBlock": 0,
  "istanbulBlock": 0,
  "muirGlacierBlock": 0,
  "subnetEVMTimestamp": 0,
  "feeConfig": {
    "gasLimit": 8000000,
    "targetBlockRate": 2,
    "minBaseFee": 25000000000,
    "targetGas": 15000000,
    "baseFeeChangeDenominator": 36,
    "minBlockGasCost": 0,
    "maxBlockGasCost": 1000000,
    "blockGasCostStep": 200000
  }
}
```

**Genesis Allocation**:
```json
{
  "alloc": {
    "0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FC": {
      "balance": "0x295BE96E64066972000000"
    }
  }
}
```

## Step 4: Deploy Locally for Testing

### Start Local Network

```bash
# Deploy L1 to local network
avalanche blockchain deploy myAppchain --local

# This will:
# - Start a local Avalanche network
# - Deploy your L1
# - Provide RPC endpoint and chain details
```

### Connect to Your L1

Add your L1 to MetaMask:
- **Network Name**: MyAppchain Local
- **RPC URL**: http://localhost:9650/ext/bc/[BLOCKCHAIN_ID]/rpc
- **Chain ID**: 12345 (your configured ID)
- **Currency Symbol**: Your token symbol
- **Block Explorer**: (optional for local)

### Test Your L1

```javascript
// Simple test script
const { ethers } = require('ethers');

async function testL1() {
  const provider = new ethers.providers.JsonRpcProvider(
    'http://localhost:9650/ext/bc/[BLOCKCHAIN_ID]/rpc'
  );
  
  // Check network
  const network = await provider.getNetwork();
  console.log('Connected to chain ID:', network.chainId);
  
  // Check balance
  const balance = await provider.getBalance('YOUR_ADDRESS');
  console.log('Balance:', ethers.utils.formatEther(balance));
}

testL1();
```

## Step 5: Deploy to Fuji Testnet

### Fund Your Deployment

```bash
# Get your P-Chain address
avalanche key list

# Fund the address on Fuji testnet
# Use Avalanche faucet: https://faucet.avax.network/
```

### Deploy to Fuji

```bash
# Deploy to Fuji testnet
avalanche blockchain deploy myAppchain --fuji

# Follow prompts to:
# - Select validators for your L1
# - Set staking parameters
# - Configure validator rewards
```

### Validator Setup

```bash
# Add validators to your L1
avalanche blockchain add-validator myAppchain --fuji

# Configure validator parameters:
# - Node ID
# - Start/End time
# - Stake amount
# - Delegation fee (if applicable)
```

## Step 6: Customize Your L1

### Add Custom Precompiles

Enhance your L1 with custom functionality:

```solidity
// Example: Custom precompile for rewards
interface IRewardManager {
    function distributeRewards(address[] memory recipients, uint256[] memory amounts) external;
    function setRewardRate(uint256 rate) external;
}
```

### Configure Advanced Features

**Allowlists and Permissions**:
```json
{
  "contractDeployerAllowListConfig": {
    "blockTimestamp": 0,
    "adminAddresses": ["0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FC"]
  },
  "txAllowListConfig": {
    "blockTimestamp": 0,
    "adminAddresses": ["0x8db97C7cEcE249c2b98bDC0226Cc4C2A57BF52FC"]
  }
}
```

**Warp Messaging** (Cross-Chain Communication):
```json
{
  "warpConfig": {
    "blockTimestamp": 0
  }
}
```

## Step 7: Deploy to Mainnet

### Security Checklist

Before mainnet deployment:
- [ ] Code audit completed
- [ ] Extensive testing on Fuji
- [ ] Validator set secured
- [ ] Governance framework established
- [ ] Economic model validated
- [ ] Emergency procedures defined

### Mainnet Deployment

```bash
# Deploy to mainnet (requires significant AVAX stake)
avalanche blockchain deploy myAppchain --mainnet

# Minimum requirements:
# - 2000 AVAX stake per validator
# - Minimum 5 validators recommended
# - Proper validator infrastructure
```

## Step 8: Build Your Ecosystem

### Developer Tools

Provide developers with:
- **Documentation**: API reference and tutorials
- **SDKs**: Language-specific libraries
- **Block Explorer**: Custom explorer for your L1
- **Faucet**: Testnet token distribution
- **Bridge Interface**: Cross-chain asset transfers

### Example Block Explorer Setup

```javascript
// Configure blockscout for your L1
const config = {
  rpc: 'https://your-l1-rpc.com',
  chainId: 12345,
  networkName: 'MyAppchain',
  currencySymbol: 'MAC'
};
```

## Step 9: Cross-Chain Integration

### Connect to Other L1s

Use Avalanche Warp Messaging:

```solidity
// Cross-chain message contract
contract CrossChainMessage {
    function sendMessage(
        bytes32 destinationChainID,
        address destinationAddress,
        bytes calldata message
    ) external {
        // Warp message implementation
    }
}
```

### Asset Bridging

Implement token bridges:
- **Native Bridge**: Using Avalanche infrastructure
- **Custom Bridge**: Application-specific bridging
- **Third-Party Bridges**: LayerZero, Axelar, etc.

## Monitoring and Maintenance

### Essential Monitoring

Track these metrics:
- **Network Health**: Block production rate
- **Validator Performance**: Uptime and responsiveness
- **Transaction Volume**: Usage patterns
- **Economic Metrics**: Token distribution and staking

### Monitoring Tools

```bash
# CLI monitoring
avalanche blockchain status myAppchain

# Custom monitoring script
#!/bin/bash
while true; do
  echo "Checking L1 health..."
  curl -X POST --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
    -H "Content-Type: application/json" \
    https://your-l1-rpc.com
  sleep 60
done
```

## Governance and Upgrades

### Governance Framework

Implement governance for:
- **Network Parameters**: Fee structure, gas limits
- **Validator Management**: Adding/removing validators
- **Upgrades**: VM updates and new features
- **Economic Policy**: Token emission, rewards

### Upgrade Process

```bash
# Upgrade your L1 VM
avalanche blockchain upgrade vm myAppchain

# Deploy network upgrades
avalanche blockchain upgrade network myAppchain
```

## Common Pitfalls

### Avoid These Mistakes

1. **Insufficient Testing**: Always test thoroughly on Fuji
2. **Poor Economics**: Unsustainable tokenomics
3. **Centralization**: Too few validators
4. **No Governance**: Lack of upgrade mechanisms
5. **Security Oversights**: Inadequate security audits

## Cost Estimation

### Deployment Costs

**Fuji Testnet**: Free (use faucet)

**Mainnet**:
- Validator Stake: 2000 AVAX per validator minimum
- 5 Validators Recommended: 10,000 AVAX (~$200,000)
- Ongoing Costs: Infrastructure and maintenance

## Next Steps

<Cards>
<Card title="Custom Virtual Machines" description="Build VMs with specialized functionality" href="/docs/avalanche-l1s/virtual-machines" />
<Card title="Cross-Chain Messaging" description="Connect your L1 to other chains" href="/docs/cross-chain/teleporter" />
<Card title="Validator Management" description="Set up and manage your validator network" href="/docs/avalanche-l1s/validator-manager" />
<Card title="EVM Customization" description="Advanced EVM configuration options" href="/docs/avalanche-l1s/evm-configuration" />
</Cards>

## Resources

- [Avalanche L1 Documentation](/docs/avalanche-l1s)
- [Avalanche CLI Reference](/docs/tooling/cli-commands)
- [L1 Examples Repository](https://github.com/ava-labs/avalanche-l1-examples)
- [Community Discord](https://discord.gg/avalanche) 
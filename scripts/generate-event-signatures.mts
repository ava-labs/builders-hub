/**
 * Script to generate event signature map from ABI files
 * This runs at build time to create a lookup table for decoding event logs
 */

import fs from 'fs';
import path from 'path';
import { keccak256 } from 'viem';

interface AbiEventInput {
  indexed: boolean;
  name: string;
  type: string;
  components?: AbiEventInput[];
}

interface AbiEvent {
  anonymous?: boolean;
  inputs: AbiEventInput[];
  name: string;
  type: 'event';
}

interface EventSignatureInput {
  name: string;
  type: string;
  indexed: boolean;
  components?: EventSignatureInput[];
}

interface EventSignature {
  name: string;
  signature: string;
  topic: string;
  indexedCount: number;
  inputs: EventSignatureInput[];
}

// Map from topic -> array of variants (different indexed param configurations)
type EventSignatureMap = Record<string, EventSignature[]>;

const ABI_DIR = path.join(process.cwd(), 'abi');
const OUTPUT_FILE = path.join(process.cwd(), 'abi/event-signatures.generated.ts');

/**
 * Recursively expand tuple types into their canonical form for signature computation.
 * Solidity event signatures use the expanded form: (type1,type2,...) instead of "tuple"
 */
function expandType(input: AbiEventInput): string {
  if (input.type === 'tuple' && input.components) {
    const innerTypes = input.components.map(expandType).join(',');
    return `(${innerTypes})`;
  }
  if (input.type === 'tuple[]' && input.components) {
    const innerTypes = input.components.map(expandType).join(',');
    return `(${innerTypes})[]`;
  }
  return input.type;
}

function getEventSignature(event: AbiEvent): string {
  const params = event.inputs.map(expandType).join(',');
  return `${event.name}(${params})`;
}

function getEventTopic(signature: string): string {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(signature);
  return keccak256(bytes);
}

function getIndexedCount(event: AbiEvent): number {
  return event.inputs.filter(input => input.indexed).length;
}

/**
 * Convert ABI input to our EventSignatureInput format, preserving components for tuples
 */
function convertInput(input: AbiEventInput, isComponent: boolean = false): EventSignatureInput {
  const result: EventSignatureInput = {
    name: input.name,
    type: input.type,
    // Components inside tuples are never indexed, only top-level event params can be
    indexed: isComponent ? false : input.indexed,
  };
  
  if (input.components) {
    result.components = input.components.map(c => convertInput(c, true));
  }
  
  return result;
}

async function generateEventSignatures(): Promise<void> {
  console.log('üîç Scanning ABI directory:', ABI_DIR);
  
  const eventMap: EventSignatureMap = {};
  
  // Read all JSON files in the abi directory
  const files = fs.readdirSync(ABI_DIR).filter(file => file.endsWith('.json'));
  
  console.log(`üìÅ Found ${files.length} ABI files`);
  
  for (const file of files) {
    const filePath = path.join(ABI_DIR, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    
    try {
      const abi = JSON.parse(content) as AbiEvent[];
      const events = abi.filter(item => item.type === 'event');
      
      console.log(`  üìÑ ${file}: ${events.length} events`);
      
      for (const event of events) {
        const signature = getEventSignature(event);
        const topic = getEventTopic(signature).toLowerCase();
        const indexedCount = getIndexedCount(event);
        
        const eventSig: EventSignature = {
          name: event.name,
          signature,
          topic,
          indexedCount,
          inputs: event.inputs.map(input => convertInput(input, false)),
        };
        
        // Initialize array if needed
        if (!eventMap[topic]) {
          eventMap[topic] = [];
        }
        
        // Check if we already have a variant with the same indexed count
        const existingVariant = eventMap[topic].find(v => v.indexedCount === indexedCount);
        if (!existingVariant) {
          eventMap[topic].push(eventSig);
          console.log(`    ‚úì ${event.name}: ${signature} ‚Üí ${topic.slice(0, 18)}...`);
        }
      }
    } catch (error) {
      console.error(`  ‚ùå Error parsing ${file}:`, error);
    }
  }
  
  const totalSignatures = Object.keys(eventMap).length;
  const totalVariants = Object.values(eventMap).reduce((sum, variants) => sum + variants.length, 0);
  const collisions = Object.values(eventMap).filter(v => v.length > 1).length;
  
  console.log(`\n‚úÖ Generated ${totalSignatures} unique event signatures (${totalVariants} variants, ${collisions} with collisions)`);
  
  // Generate the TypeScript file
  const output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: scripts/generate-event-signatures.mts
 * 
 * This file contains event signature mappings for decoding EVM logs
 */

export interface EventInput {
  name: string;
  type: string;
  indexed: boolean;
  components?: EventInput[];
}

export interface EventSignature {
  name: string;
  signature: string;
  topic: string;
  indexedCount: number;
  inputs: EventInput[];
}

/**
 * Map from topic hash to array of event signature variants.
 * Multiple variants exist when different contracts have the same event signature
 * but different indexed parameters (e.g., ERC20 vs ERC721 Transfer).
 */
export const EVENT_SIGNATURES: Record<string, EventSignature[]> = ${JSON.stringify(eventMap, null, 2)};

/**
 * Get all event signature variants by topic hash
 */
export function getEventVariantsByTopic(topic: string): EventSignature[] | undefined {
  return EVENT_SIGNATURES[topic.toLowerCase()];
}

/**
 * Get the best matching event signature based on log structure.
 * Uses the number of indexed topics to determine the correct variant.
 */
export function getEventByTopic(topic: string, topicsCount: number): EventSignature | undefined {
  const variants = EVENT_SIGNATURES[topic.toLowerCase()];
  if (!variants || variants.length === 0) return undefined;
  
  // topicsCount includes topic[0] (event signature), so indexed params = topicsCount - 1
  const indexedParamsCount = topicsCount - 1;
  
  // Find variant matching the indexed count
  const exactMatch = variants.find(v => v.indexedCount === indexedParamsCount);
  if (exactMatch) return exactMatch;
  
  // Fallback to first variant if no exact match
  return variants[0];
}

/**
 * Format a decoded value for display based on its type
 */
function formatValue(value: string, type: string): string {
  if (type === 'address') {
    return '0x' + value.slice(-40);
  }
  if (type.startsWith('uint') || type.startsWith('int')) {
    try {
      return BigInt(value.startsWith('0x') ? value : '0x' + value).toString();
    } catch {
      return value;
    }
  }
  if (type === 'bool') {
    try {
      return BigInt(value.startsWith('0x') ? value : '0x' + value) !== BigInt(0) ? 'true' : 'false';
    } catch {
      return value;
    }
  }
  return value;
}

/**
 * Decode tuple data from the data field
 */
function decodeTupleData(
  data: string,
  offset: number,
  components: EventInput[]
): { values: Array<{ name: string; type: string; value: string }>; bytesConsumed: number } {
  const values: Array<{ name: string; type: string; value: string }> = [];
  let currentOffset = offset;
  
  for (const component of components) {
    if (component.type === 'tuple' && component.components) {
      // Nested tuple - recurse
      const result = decodeTupleData(data, currentOffset, component.components);
      values.push({
        name: component.name,
        type: component.type,
        value: JSON.stringify(result.values),
      });
      currentOffset += result.bytesConsumed;
    } else if (component.type.endsWith('[]')) {
      // Array type - skip for now, just read the offset
      if (data.length >= currentOffset + 64) {
        const chunk = data.slice(currentOffset, currentOffset + 64);
        values.push({
          name: component.name,
          type: component.type,
          value: '[array]',
        });
        currentOffset += 64;
      }
    } else if (component.type === 'bytes' || component.type === 'string') {
      // Dynamic type - read offset pointer
      if (data.length >= currentOffset + 64) {
        const chunk = data.slice(currentOffset, currentOffset + 64);
        values.push({
          name: component.name,
          type: component.type,
          value: '[dynamic]',
        });
        currentOffset += 64;
      }
    } else {
      // Fixed-size type
      if (data.length >= currentOffset + 64) {
        const chunk = data.slice(currentOffset, currentOffset + 64);
        values.push({
          name: component.name,
          type: component.type,
          value: formatValue('0x' + chunk, component.type),
        });
        currentOffset += 64;
      }
    }
  }
  
  return { values, bytesConsumed: currentOffset - offset };
}

/**
 * Decode event log using the signature map
 */
export function decodeEventLog(log: { topics: string[]; data: string }): {
  name: string;
  signature: string;
  params: Array<{ name: string; type: string; value: string; indexed: boolean; components?: Array<{ name: string; type: string; value: string }> }>;
} | null {
  if (!log.topics || log.topics.length === 0) return null;
  
  const eventSig = getEventByTopic(log.topics[0], log.topics.length);
  if (!eventSig) return null;
  
  const params: Array<{ name: string; type: string; value: string; indexed: boolean; components?: Array<{ name: string; type: string; value: string }> }> = [];
  
  let topicIndex = 1;
  let dataOffset = 0;
  const data = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
  
  for (const input of eventSig.inputs) {
    let value = '';
    let decodedComponents: Array<{ name: string; type: string; value: string }> | undefined;
    
    if (input.indexed) {
      // Indexed parameters are in topics
      if (topicIndex < log.topics.length) {
        const topic = log.topics[topicIndex];
        value = formatValue(topic, input.type);
        topicIndex++;
      }
    } else {
      // Non-indexed parameters are in data
      if (input.type === 'tuple' && input.components) {
        // Decode tuple
        const result = decodeTupleData(data, dataOffset, input.components);
        decodedComponents = result.values;
        value = \`(\${result.values.map(v => v.value).join(', ')})\`;
        dataOffset += result.bytesConsumed;
      } else if (data.length >= dataOffset + 64) {
        const chunk = data.slice(dataOffset, dataOffset + 64);
        value = formatValue('0x' + chunk, input.type);
        dataOffset += 64;
      }
    }
    
    const param: { name: string; type: string; value: string; indexed: boolean; components?: Array<{ name: string; type: string; value: string }> } = {
      name: input.name,
      type: input.type,
      value,
      indexed: input.indexed,
    };
    
    if (decodedComponents) {
      param.components = decodedComponents;
    }
    
    params.push(param);
  }
  
  return {
    name: eventSig.name,
    signature: eventSig.signature,
    params,
  };
}
`;
  
  fs.writeFileSync(OUTPUT_FILE, output);
  console.log(`üìù Written to: ${OUTPUT_FILE}`);
}

generateEventSignatures().catch(console.error);

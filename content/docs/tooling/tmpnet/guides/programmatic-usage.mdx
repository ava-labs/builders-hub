---
title: Programmatic Usage
description: Use tmpnet in your Go tests and applications for automated network management
---

This guide shows you how to use tmpnet programmatically in your Go code for automated testing and development workflows.

## Overview

Use tmpnet programmatically to:

- Integrate networks into automated tests
- Customize configurations in code
- Manage network lifecycle
- Share network state across tests

## Getting Started

### Import tmpnet

Add tmpnet to your Go module:

```bash
go get github.com/ava-labs/avalanchego/tests/fixture/tmpnet
```

Import in your code:

```go
import (
    "github.com/ava-labs/avalanchego/tests/fixture/tmpnet"
)
```

### Basic Network Creation

Create a simple 5-node network:

```go
package main

import (
    "context"
    "fmt"
    "os"
    "time"

    "github.com/ava-labs/avalanchego/tests/fixture/tmpnet"
    "github.com/ava-labs/avalanchego/utils/logging"
)

func main() {
    // Create network with 5 validator nodes
    network := &tmpnet.Network{
        Nodes: tmpnet.NewNodesOrPanic(5),
        DefaultRuntimeConfig: tmpnet.NodeRuntimeConfig{
            Process: &tmpnet.ProcessRuntimeConfig{
                AvalancheGoPath: "./build/avalanchego",
                PluginDir:       os.ExpandEnv("$HOME/.avalanchego/plugins"),
            },
        },
    }

    // Bootstrap the network
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
    defer cancel()

    err := tmpnet.BootstrapNewNetwork(
        ctx,
        logging.NoLog{}, // Use logging.NoLog{} or a real logger
        network,
        "",              // Use default network directory (~/.tmpnet/networks)
    )
    if err != nil {
        panic(err)
    }

    fmt.Println("Network started successfully!")

    // Get node URIs
    for i, node := range network.Nodes {
        fmt.Printf("Node %d: %s\n", i, node.URI)
    }

    // Use the network...

    // Stop when done
    network.Stop(context.Background())
}
```

## Network Configuration

### Customizing Node Flags

Set default flags for all nodes in the network:

```go
network := &tmpnet.Network{
    Nodes: tmpnet.NewNodesOrPanic(5),
    DefaultFlags: tmpnet.FlagsMap{
        "log-level":              "debug",
        "log-display-level":      "info",
        "network-max-reconnect-delay": "1s",
        "public-ip":              "127.0.0.1",
    },
}
```

### Per-Node Configuration

Customize individual nodes:

```go
network := &tmpnet.Network{
    Nodes: tmpnet.NewNodesOrPanic(3),
}

// Configure first node differently
network.Nodes[0].Flags = tmpnet.FlagsMap{
    "log-level": "trace", // More verbose logging
}

// Configure second node with specific API port
network.Nodes[1].Flags = tmpnet.FlagsMap{
    "http-port": "9650", // Fixed port instead of dynamic
}
```

### Runtime Configuration

Configure how nodes are executed:

```go
network := &tmpnet.Network{
    Nodes: tmpnet.NewNodesOrPanic(5),
    DefaultRuntimeConfig: tmpnet.NodeRuntimeConfig{
        Process: &tmpnet.ProcessRuntimeConfig{
            AvalancheGoPath: "/custom/path/to/avalanchego",
            PluginDir:       "/custom/plugin/dir",
            ReuseDynamicPorts: true, // Reuse ports on restart
        },
    },
}
```

## Network Lifecycle Management

### Starting and Stopping Networks

```go
// Create network configuration
network := &tmpnet.Network{
    Nodes: tmpnet.NewNodesOrPanic(5),
}

// Bootstrap (create and start)
ctx := context.Background()
err := tmpnet.BootstrapNewNetwork(ctx, logging.NoLog{}, network, "")

// Stop all nodes
err = network.Stop(ctx)

// Restart the network
err = network.Restart(ctx)

// Start specific nodes
err = network.StartNodes(ctx, network.Nodes[0], network.Nodes[1])
```

### Reading Existing Networks

Load a previously created network from disk:

```go
networkDir := "~/.tmpnet/networks/20240312-143052.123456"

network, err := tmpnet.ReadNetwork(context.Background(), os.Stdout, networkDir)
if err != nil {
    panic(err)
}

// Network configuration is loaded and ready to use
fmt.Println("Loaded network with", len(network.Nodes), "nodes")
```

### Managing Individual Nodes

```go
// Start a single node
err := network.StartNode(ctx, network.Nodes[0])

// Stop a single node
err = network.Nodes[0].Stop(ctx)

// Restart a single node
err = network.Nodes[0].Restart(ctx)

// Wait for node to be healthy
err = network.Nodes[0].WaitForHealthy(ctx)

// Check if node is healthy
isHealthy := network.Nodes[0].IsHealthy()
```

## Integration with Testing Frameworks

### Using with Go's testing Package

```go
package mytest

import (
    "context"
    "testing"
    "time"

    "github.com/ava-labs/avalanchego/tests/fixture/tmpnet"
)

func TestWithTmpnet(t *testing.T) {
    // Create network
    network := &tmpnet.Network{
        Nodes: tmpnet.NewNodesOrPanic(5),
        DefaultRuntimeConfig: tmpnet.NodeRuntimeConfig{
            Process: &tmpnet.ProcessRuntimeConfig{
                AvalancheGoPath: "./build/avalanchego",
                PluginDir:       os.ExpandEnv("$HOME/.avalanchego/plugins"),
            },
        },
    }

    // Bootstrap
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
    defer cancel()

    // Create a logger that writes to the test log
    logger := logging.NewLogger("", logging.NewWrappedCore(
        logging.Info,
        io.Discard,
        logging.Plain.ConsoleEncoder(),
    ))

    err := tmpnet.BootstrapNewNetwork(ctx, logger, network, "")
    if err != nil {
        t.Fatal("Failed to bootstrap network:", err)
    }

    // Ensure cleanup
    defer func() {
        if err := network.Stop(context.Background()); err != nil {
            t.Error("Failed to stop network:", err)
        }
    }()

    // Run your tests
    t.Run("TestTransactions", func(t *testing.T) {
        testTransactions(t, network)
    })

    t.Run("TestConsensus", func(t *testing.T) {
        testConsensus(t, network)
    })
}
```

### Using with Ginkgo

tmpnet works well with Ginkgo for BDD-style tests:

```go
package mytest

import (
    "context"
    "time"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
    "github.com/ava-labs/avalanchego/tests/fixture/tmpnet"
)

var _ = Describe("My Feature", func() {
    var network *tmpnet.Network

    BeforeEach(func() {
        network = &tmpnet.Network{
            Nodes: tmpnet.NewNodesOrPanic(5),
            DefaultRuntimeConfig: tmpnet.NodeRuntimeConfig{
                Process: &tmpnet.ProcessRuntimeConfig{
                    AvalancheGoPath: "./build/avalanchego",
                    PluginDir:       os.ExpandEnv("$HOME/.avalanchego/plugins"),
                },
            },
        }

        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        err := tmpnet.BootstrapNewNetwork(ctx, logging.NoLog{}, network, "")
        Expect(err).NotTo(HaveOccurred())

        DeferCleanup(func() {
            Expect(network.Stop(context.Background())).To(Succeed())
        })
    })

    It("should process transactions", func() {
        // Test with network
    })
})
```

### Shared Network Pattern

Share a network across multiple tests for efficiency:

```go
var _ = Describe("Feature Tests", func() {
    var sharedNetwork *tmpnet.Network

    // Bootstrap once for all tests
    BeforeSuite(func() {
        sharedNetwork = &tmpnet.Network{
            Nodes: tmpnet.NewNodesOrPanic(5),
            DefaultRuntimeConfig: tmpnet.NodeRuntimeConfig{
                Process: &tmpnet.ProcessRuntimeConfig{
                    AvalancheGoPath: "./build/avalanchego",
                    PluginDir:       os.ExpandEnv("$HOME/.avalanchego/plugins"),
                },
            },
        }

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        err := tmpnet.BootstrapNewNetwork(ctx, logging.NoLog{}, sharedNetwork, "")
        Expect(err).NotTo(HaveOccurred())
    })

    // Clean up after all tests
    AfterSuite(func() {
        if sharedNetwork != nil {
            Expect(sharedNetwork.Stop(context.Background())).To(Succeed())
        }
    })

    It("Test 1", func() {
        // Use sharedNetwork
    })

    It("Test 2", func() {
        // Use sharedNetwork
    })
})
```

## Working with Pre-funded Keys

Access pre-funded keys for transactions:

```go
network := &tmpnet.Network{
    Nodes: tmpnet.NewNodesOrPanic(5),
}

// Create additional pre-funded keys
key1, err := tmpnet.NewPrivateKey()
key2, err := tmpnet.NewPrivateKey()

network.PreFundedKeys = []*secp256k1.PrivateKey{key1, key2}

// After bootstrap, keys are funded in genesis
// Use them for transactions
keychain := secp256k1fx.NewKeychain(network.PreFundedKeys...)
```

## Adding Ephemeral Nodes

Add temporary nodes for specific test scenarios:

```go
// Create an ephemeral node
ephemeralNode := tmpnet.NewEphemeralNode(tmpnet.FlagsMap{
    "log-level": "debug",
})

// Start the node
err := network.StartNode(context.Background(), ephemeralNode)
if err != nil {
    panic(err)
}

// Wait for it to be healthy
err = ephemeralNode.WaitForHealthy(context.Background())

// Use the node...

// Stop and remove (automatic cleanup with Ginkgo's DeferCleanup)
defer ephemeralNode.Stop(context.Background())
```

## Network Utilities

### Getting Node URIs

```go
// Get all node URIs
uris := network.GetNodeURIs()
for _, uri := range uris {
    fmt.Println("Node URI:", uri)
}

// Get a random node URI
randomURI := network.GetRandomNodeURI()
```

### Getting Node IDs

```go
// Get all node IDs
nodeIDs := tmpnet.NodesToIDs(network.Nodes)

// Get bootstrap IPs and IDs
bootstrapIPs, bootstrapIDs := network.GetBootstrapIPsAndIDs()
```

### Health Checking

```go
// Check if a node is healthy
healthy := tmpnet.CheckNodeHealth(context.Background(), node.URI)

// Wait for all nodes to be healthy
err := tmpnet.WaitForHealthyNodes(context.Background(), network.Nodes)
```

## Advanced Patterns

### Network Reuse Across Test Runs

Save time by reusing a network:

```go
// First run: create and save network path
network := createNetwork()
networkPath := network.Dir

// Subsequent runs: load existing network
network, err := tmpnet.ReadNetwork(ctx, os.Stdout, networkPath)
if err != nil {
    // Network doesn't exist or is invalid, create new one
    network = createNetwork()
}
```

### Custom Network Directory

Specify where networks are created:

```go
customDir := "/tmp/my-test-networks"

err := tmpnet.BootstrapNewNetwork(
    ctx,
    logging.NoLog{},
    network,
    customDir, // Custom root directory
)
```

### Network Configuration Validation

Validate configuration before bootstrapping:

```go
network := &tmpnet.Network{
    Nodes: tmpnet.NewNodesOrPanic(5),
}

// Validate configuration
err := network.EnsureDefaultConfig(os.Stdout, avalanchegoPath, pluginDir)
if err != nil {
    panic("Invalid network configuration: " + err.Error())
}

// Create network structure on disk
err = network.Create(networkDir)
if err != nil {
    panic(err)
}

// Start nodes
err = network.Bootstrap(ctx, os.Stdout)
```

### Parallel Network Creation

Create multiple networks concurrently for parallel testing:

```go
func createNetworks(count int) []*tmpnet.Network {
    networks := make([]*tmpnet.Network, count)
    errors := make([]error, count)

    var wg sync.WaitGroup
    for i := 0; i < count; i++ {
        wg.Add(1)
        go func(index int) {
            defer wg.Done()

            network := &tmpnet.Network{
                Nodes: tmpnet.NewNodesOrPanic(3),
                DefaultRuntimeConfig: tmpnet.NodeRuntimeConfig{
                    Process: &tmpnet.ProcessRuntimeConfig{
                        AvalancheGoPath: "./build/avalanchego",
                        PluginDir:       os.ExpandEnv("$HOME/.avalanchego/plugins"),
                    },
                },
            }

            ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
            defer cancel()

            err := tmpnet.BootstrapNewNetwork(ctx, logging.NoLog{}, network, "")
            networks[index] = network
            errors[index] = err
        }(i)
    }

    wg.Wait()

    // Check for errors
    for _, err := range errors {
        if err != nil {
            panic(err)
        }
    }

    return networks
}
```

## Error Handling

### Enabling Stack Traces

For better debugging, enable stack traces:

```bash
export STACK_TRACE_ERRORS=1
```

Then errors from tmpnet will include full stack traces.

### Handling Timeouts

Set appropriate timeouts for network operations:

```go
// Short timeout for quick operations
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

err := network.StartNode(ctx, node)
if err != nil {
    if ctx.Err() == context.DeadlineExceeded {
        fmt.Println("Node start timed out")
    }
}

// Longer timeout for full bootstrap
bootstrapCtx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()

err = tmpnet.BootstrapNewNetwork(bootstrapCtx, logging.NoLog{}, network, "")
```

## Best Practices

1. **Always use timeouts** - Network operations should have reasonable timeouts
2. **Clean up resources** - Always stop networks when done, use defer or DeferCleanup
3. **Share networks when possible** - Reuse networks across tests to save time
4. **Use ephemeral nodes for isolation** - Add temporary nodes for isolated testing
5. **Enable detailed logging during development** - Use `log-level: debug` for troubleshooting
6. **Check health before testing** - Verify nodes are healthy before running tests

## Next Steps

<Cards>
  <Card title="Testing Custom VMs" href="/docs/tooling/tmpnet/guides/testing-custom-vms">
    Deploy and test custom Virtual Machines
  </Card>
  <Card title="Subnet Testing" href="/docs/tooling/tmpnet/guides/subnet-testing">
    Advanced subnet testing scenarios
  </Card>
  <Card title="Configuration Reference" href="/docs/tooling/tmpnet/reference/configuration">
    Detailed configuration options
  </Card>
</Cards>

## Additional Resources

- [E2E Test Examples](https://github.com/ava-labs/avalanchego/tree/master/tests/e2e)
- [tmpnet Package Documentation](https://pkg.go.dev/github.com/ava-labs/avalanchego/tests/fixture/tmpnet)
- [Full README](https://github.com/ava-labs/avalanchego/blob/master/tests/fixture/tmpnet/README.md)

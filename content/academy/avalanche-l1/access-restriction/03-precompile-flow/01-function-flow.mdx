---
title: From Solidity to Go
description: Understand how your Solidity calls to precompile interfaces execute Go code at the VM level.
updated: 2025-12-17
authors: [nicolasarnedo]
icon: Book
---

import { Callout } from 'fumadocs-ui/components/callout';
import Mermaid from "@/components/mermaid";

## Overview

When you call a precompile from Solidity, you're not calling a deployed smart contract—you're invoking **Go code built into the VM**. This lesson explains exactly how that works.

The key insight: precompiles look like regular contracts from Solidity's perspective, but the EVM routes calls to reserved addresses directly to Go implementations instead of executing bytecode.

## The High-Level Flow

When your transaction calls a precompile (like the Transaction AllowList), here's what happens:

<Mermaid chart={`
sequenceDiagram
    participant User as Your Wallet
    participant EVM as EVM
    participant Hook as PrecompileOverride
    participant Module as Precompile Module (Go)
    participant State as StateDB

    User->>EVM: Call 0x0200...0002 with setEnabled(addr)
    EVM->>Hook: Is this address a precompile?
    Hook->>Hook: Yes - get registered module
    Hook->>Module: Execute Run() with input data
    Module->>Module: Parse function selector (first 4 bytes)
    Module->>State: Read caller's role
    State-->>Module: Role = Admin
    Module->>State: Write new role for target address
    Module-->>Hook: Return success + gas used
    Hook-->>EVM: Result
    EVM-->>User: Transaction succeeded
`} />

## Step-by-Step Breakdown

### 1. Your Solidity Call

When you call a precompile from Solidity, it looks like any other contract call:

```solidity
IAllowList allowlist = IAllowList(0x0200000000000000000000000000000000000002);
allowlist.setEnabled(someAddress);
```

The compiler generates a `CALL` opcode targeting the precompile address with your function call encoded as ABI data.

### 2. EVM Recognizes the Precompile Address

When the EVM encounters a call to an address in the reserved range (`0x0200...`), it checks if there's a registered precompile:

```go
// PrecompileOverride checks if address has a registered precompile
func (r RulesExtra) PrecompileOverride(addr common.Address) (libevm.PrecompiledContract, bool) {
    module, ok := modules.GetPrecompileModuleByAddress(addr)
    if !ok {
        return nil, false  // Not a precompile, use normal execution
    }
    return makePrecompile(module.Contract), true  // Route to Go code
}
```

<Callout type="info">
Reserved address ranges for precompiles:
- `0x0100...00` to `0x0100...ff`
- `0x0200...00` to `0x0200...ff` (where allowlist precompiles live)
- `0x0300...00` to `0x0300...ff`
</Callout>

### 3. Function Selector Dispatch

The precompile receives your call and parses the **function selector** (first 4 bytes of input data) to determine which function you're calling:

```go
// The Run method receives raw input bytes
func (c *Contract) Run(
    accessibleState contract.AccessibleState,
    caller common.Address,
    addr common.Address,
    input []byte,
    suppliedGas uint64,
    readOnly bool,
) (ret []byte, remainingGas uint64, err error) {
    
    // First 4 bytes = function selector
    selector := input[:4]
    
    // Match against known function selectors
    switch {
    case bytes.Equal(selector, setAdminSelector):
        return c.setAdmin(accessibleState, caller, input[4:], suppliedGas)
    case bytes.Equal(selector, setEnabledSelector):
        return c.setEnabled(accessibleState, caller, input[4:], suppliedGas)
    case bytes.Equal(selector, readAllowListSelector):
        return c.readAllowList(accessibleState, input[4:], suppliedGas)
    }
}
```

### 4. Permission Check & State Access

Before modifying state, the precompile checks the caller's permission level:

<Mermaid chart={`
graph TD
    A[Caller Address] --> B[Read from StateDB]
    B --> C{Caller Role?}
    C -->|Admin| D[Can modify any role]
    C -->|Manager| E[Can only set Enabled]
    C -->|Enabled/None| F[Revert: Unauthorized]
    D --> G[Write new role to StateDB]
    E --> G
`} />

The state is stored just like any contract storage—using `GetState` and `SetState`:

```go
// Read a role from storage
func getAllowListRole(state StateDB, addr common.Address) uint8 {
    key := crypto.Keccak256Hash(addr.Bytes())
    value := state.GetState(PrecompileAddress, key)
    return uint8(value[31])  // Role is stored in last byte
}

// Write a role to storage
func setAllowListRole(state StateDB, addr common.Address, role uint8) {
    key := crypto.Keccak256Hash(addr.Bytes())
    value := common.BytesToHash([]byte{role})
    state.SetState(PrecompileAddress, key, value)
}
```

### 5. Gas Accounting

Precompiles have fixed gas costs defined in Go:

```go
const (
    WriteGasCostPerSlot = 20_000  // Writing to storage
    ReadGasCostPerSlot  = 5_000   // Reading from storage
)
```

The precompile deducts gas and returns the remaining amount:

```go
return result, suppliedGas - ReadGasCostPerSlot, nil
```

## How Allowlist Enforcement Works

The allowlist precompiles don't just store permissions—they **enforce** them before transactions execute:

<Mermaid chart={`
graph TD
    A[Transaction Submitted] --> B[EVM Pre-checks]
    B --> C{Contract Creation?}
    C -->|Yes| D[Check Contract Deployer AllowList]
    C -->|No| E{Any Transaction?}
    E --> F[Check Transaction AllowList]
    D --> G{Sender Enabled?}
    F --> G
    G -->|Yes| H[Execute Transaction]
    G -->|No| I[Reject Transaction]
`} />

This enforcement happens via **hooks** in the EVM execution path:

```go
// Called before any contract creation
func (r RulesExtra) CanCreateContract(caller common.Address, gas uint64) (uint64, error) {
    role := getDeployerAllowListRole(caller)
    if role < RoleEnabled {
        return gas, errors.New("sender not authorized to deploy contracts")
    }
    return gas, nil
}

// Called before any transaction execution  
func (r RulesExtra) CanExecuteTransaction(from common.Address) error {
    role := getTxAllowListRole(from)
    if role < RoleEnabled {
        return errors.New("sender not authorized to transact")
    }
    return nil
}
```

## The Complete Picture

<Mermaid chart={`
graph TB
    subgraph "Solidity Interface"
        A[IAllowList.sol] --> B["setAdmin(address)"]
        A --> C["setEnabled(address)"]
        A --> D["readAllowList(address)"]
    end

    subgraph "EVM Routing"
        E[CALL to 0x0200...0002] --> F{PrecompileOverride}
        F --> G[Get Module by Address]
    end

    subgraph "Go Implementation"
        G --> H[Parse Function Selector]
        H --> I[Check Caller Permission]
        I --> J[Read/Write StateDB]
        J --> K[Return Result + Gas]
    end

    subgraph "State Storage"
        J --> L[Storage Trie]
        L --> M["Key: keccak256(address)"]
        M --> N["Value: Role (0-2)"]
    end

    B --> E
    C --> E
    D --> E
`} />

## Key Takeaways

| Concept | What Happens |
|---------|--------------|
| **Solidity Call** | Generates `CALL` opcode to precompile address with ABI-encoded data |
| **EVM Routing** | `PrecompileOverride` intercepts calls to reserved addresses |
| **Function Dispatch** | First 4 bytes of input determine which Go function runs |
| **State Storage** | Precompiles use same `GetState`/`SetState` as regular contracts |
| **Gas Costs** | Fixed costs: 5,000 gas per read, 20,000 gas per write |
| **Enforcement** | Hooks check permissions before transaction execution |

## Why This Matters

Understanding this flow helps you:

1. **Debug issues**: Know where to look when transactions fail
2. **Understand gas costs**: Precompile operations have fixed, predictable costs
3. **Trust the security model**: Permission checks happen at the VM level, not in Solidity
4. **Build confidently**: The same pattern applies to all Avalanche L1 precompiles

In the next lessons, you'll see this flow in action by interacting with the allowlist precompiles through the Builder Console.
